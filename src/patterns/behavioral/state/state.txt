    Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от
своего состояния. Извне создаётся впечатление, что изменился класс объекта.


Проблема:
    Основная идея в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг
друга. Набор этих состояний, а также переходов между ними, предопределён и конечен. Находясь в разных состояниях,
программа может по-разному реагировать на одни и те же события, которые происходят с ней.

Машину состояний чаще всего реализуют с помощью множества условных операторов, if либо switch, которые проверяют текущее
состояние объекта и выполняют соответствующее поведение.Основная проблема такой машины состояний проявится в том случае,
если добавить ещё десяток состояний. Каждый метод будет состоять из увесистого условного оператора, перебирающего
доступные состояния. Такой код крайне сложно поддерживать. Малейшее изменение логики переходов заставит вас
перепроверять работу всех методов, которые содержат условные операторы машины состояний.

Решение:
    Паттерн Состояние предлагает создать отдельные классы для каждого состояния, в котором может пребывать объект, а
затем вынести туда поведения, соответствующие этим состояниям.
    Вместо того, чтобы хранить код всех состояний, первоначальный объект, называемый контекстом, будет содержать ссылку
на один из объектов-состояний и делегировать ему работу, зависящую от состояния.


Применимость:
     *)Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём
типов состояний много, и их код часто меняется.
     *) Когда вы сознательно используете табличную машину состояний, построенную на условных операторах, но вынуждены
мириться с дублированием кода для похожих состояний и переходов.


Шаги реализации:

1)Определитесь с классом, который будет играть роль контекста. Это может быть как существующий класс, в котором уже есть
зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.
2)Создайте общий интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных в контексте.
Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.
3)Для каждого фактического состояния создайте класс, реализующий интерфейс состояния. Переместите код, связанный с
конкретными состояниями в нужные классы. В конце концов, все методы интерфейса состояния должны быть реализованы во всех
классах состояний.
    При переносе поведения из контекста вы можете столкнуться с тем, что это поведение зависит от приватных полей или
методов контекста, к которым нет доступа из объекта состояния. Существует парочка способов обойти эту проблему.
  Самый простой — оставить поведение внутри контекста, вызывая его из объекта состояния. С другой стороны, вы можете
сделать классы состояний вложенными в класс контекста, и тогда они получат доступ ко всем приватным частям контекста.
Но последний способ доступен только в некоторых языках программирования (например, Java, C#).
4)Создайте в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения этого поля.
5)Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих методов
объекта-состояния.
6)Разместите код, который переключает состояние контекста внутри контекста.

Преимущества :
    1)Избавляет от множества больших условных операторов машины состояний.
    2)Концентрирует в одном месте код, связанный с определённым состоянием.
    3)Упрощает код контекста.

Недостатки:
     Может неоправданно усложнить код, если состояний мало и они редко меняются.
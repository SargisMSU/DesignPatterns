    Посетитель — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не
изменяя классы объектов, над которыми эти операции могут выполняться.

Аналогия из жизни
    Представьте начинающего страхового агента, жаждущего получить новых клиентов. Он беспорядочно посещает все дома в
округе, предлагая свои услуги. Но для каждого из посещаемых типов домов у него имеется особое предложение:
    *)Придя в дом к обычной семье, он предлагает оформить медицинскую страховку.
    *)Придя в банк, он предлагает страховку от грабежа.
    *)Придя на фабрику, он предлагает страховку предприятия от пожара и наводнения.

    Применимость:
    *) Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.
    *) Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но
    вы не хотите «засорять» классы такими операциями.
    *) Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.

Шаги реализации
    1)Создайте интерфейс посетителя и объявите в нём методы «посещения» для каждого класса элемента, который существует
    в программе.
    2) Опишите интерфейс элементов. Если вы работаете с уже существующими классами, то объявите абстрактный метод
    принятия посетителей в базовом классе иерархии элементов.
    3) Реализуйте методы принятия во всех конкретных элементах. Они должны переадресовывать вызовы тому методу посетителя,
    в котором тип параметра совпадает с текущим классом элемента.
    4) Иерархия элементов должна знать только о базовом интерфейсе посетителей. С другой стороны, посетители будут знать
    обо всех классах элементов.
    5) Для каждого нового поведения создайте конкретный класс посетителя. Приспособьте это поведение для работы со всеми
    типами элементов, реализовав все методы интерфейса посетителей.
    6)Клиент будет создавать объекты посетителей, а затем передавать их элементам, используя метод принятия.

    Преимущества
*) Упрощает добавление операций, работающих со сложными структурами объектов.
*) Объединяет родственные операции в одном классе.
*) Посетитель может накапливать состояние при обходе структуры элементов.

    Недостатки
*) Паттерн не оправдан, если иерархия элементов часто меняется.
*) Может привести к нарушению инкапсуляции элементов.





